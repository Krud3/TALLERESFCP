\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{listings}
\usepackage{amsfonts} 
\usepackage{xcolor} 
\usepackage[margin=1in]{geometry} 
\lstset{
    language=Scala,  % lenguaje de programación
    basicstyle=\ttfamily\small,  % estilo de la fuente del código
    numbers=left,  % posición de los números de línea
    numberstyle=\tiny\color{gray},  % estilo de los números de línea
    stepnumber=1,  % el paso entre dos números de línea
    numbersep=5pt,  % cómo de lejos están los números de línea del código
    backgroundcolor=\color{white},  % color de fondo
    showspaces=false,  % mostrar espacios añadiendo particular subrayado
    showstringspaces=false,  % subrayar espacios dentro de las cadenas
    showtabs=false,  % mostrar tabs dentro de las cadenas añadiendo particular subrayado
    frame=single,  % añade un marco al código
    rulecolor=\color{black},  % si no se establece, el color del marco será el del texto
    tabsize=2,  % tamaño de los tabs
    captionpos=b,  % posición del título de la tabla (t=top, b=bottom)
    breaklines=true,  % establecer si las líneas automáticas se rompen
    breakatwhitespace=false, 
    escapeinside={\%*}{*)},  % si quieres añadir LaTeX dentro de tu código
    keywordstyle=\color{blue},  % estilo de las palabras clave
    commentstyle=\color{olive},  % estilo de los comentarios
    stringstyle=\color{violet},  % estilo de las cadenas
}
\graphicspath{ {./images/} }
\title{
  \begin{figure}[th]
    \centering
    \includegraphics[width=0.2\textwidth]{Univalle}
  \end{figure}
  \textbf{Universidad del Valle
    \\{\Large Facultad de ingeniería}
  \\{\large Ingeniería en sistemas}}}
\author{Cristian David Pacheco Torres
  \\ 2227437
  \\ Juan Sebastian Molina Cuellar
  \\ 2224491}
\date{\today}

\begin{document}
\maketitle
{Taller 4: Colecciones y Expresiones For:
\\ El problema de la subsecuencia incremental de longitud máxima}
\newpage{}

\tableofcontents
\newpage{}
\section{Vista general. Uso de colecciones y expresiones for.}
El uso de colecciones y expresiones \texttt{for} en Scala representa una poderosa combinación que facilita la manipulación y transformación de datos. Las colecciones ofrecen una amplia gama de operaciones que permiten trabajar con conjuntos de datos de manera eficiente y expresiva. Por otro lado, las expresiones \texttt{for} proporcionan una sintaxis concisa para iterar y filtrar datos, haciendo que el código sea más legible y mantenible. Juntas, estas herramientas permiten a los desarrolladores escribir algoritmos complejos de manera más intuitiva, reduciendo la posibilidad de errores y mejorando la productividad.

\section{Solución ingenua usando fuerza bruta}
\subsection{Generación de los índices asociados a todas las subsecuencias}
\subsubsection{Informe de uso de colecciones y expresiones for}
\begin{lstlisting}[caption=Código en Scala para la funcion subindices, label=lst:scala_code]
  def subindices(i: Int, n: Int): Set[Seq[Int]] = {
      val elements = (i until n).toSet
      (for {
          k <- 0 to elements.size
          combination <- elements.subsets(k)
      } yield combination.toSeq.sorted ).toSet 
  }
      \end{lstlisting}
\begin{table}[H]
    \scriptsize
   \begin{tabular}{ |p{4cm}|p{3cm}|p{5.5cm}|  }
    \hline
    \multicolumn{3}{|c|}{Tabla $subindices(i:Int,n:nt)$} \\
    \hline
    \textbf{Función}& ¿Se utilizó colecciones y expresiones for?  & ¿Razón?\\
    \hline
     $subindices(i:Int,n:Int)$... & Sí &  
       \textbf{Colecciones en Scala:} 
      \begin{itemize}
          \item \texttt{Set} y \texttt{Seq} permiten representar y manipular conjuntos y secuencias de datos de manera eficiente.
          \item \texttt{subsets(k)} es una función de las colecciones que facilita la generación de todas las combinaciones posibles de un conjunto.
          \item \texttt{toSeq.sorted} convierte un conjunto en una secuencia ordenada, lo cual es útil para garantizar la consistencia en las combinaciones generadas.
      \end{itemize}
      
       \textbf{Expresiones \texttt{for}:} 
      \begin{itemize}
          \item Facilitan la iteración sobre colecciones y la generación de nuevas colecciones.
          \item Permiten combinar múltiples generadores y filtros en una sola expresión, simplificando el código y haciéndolo más legible.
      \end{itemize}
   \\
     \hline
   \end{tabular}
   \centering
   \caption{Tabla de uso de colecciones y expresiones for en la función $subindices(i:Int,n:Int)$}
   \end{table}

\subsubsection{Informe de corrección}
\textbf{Argumentación sobre la corrección: \\}


 \[ \text{Sea } i, n \in \mathbb{N}^{+} \mid 0 \leq i \leq n;\] 
 \[ \text{Sea } S  = \{a_1,a_i,...,a_{n}\} \text{ donde } a_{i-1} < a_i \text{ una secuencia denominada incremental;} \] \
 \[ \text{Sea } P(S) \text{el conjunto potencia de } s_i, \text{es decir} s \in P(S) \text{ cuando } s_i \text{ esta contenido en} S \] 
 \[ \text{Esto es } s_i \text{ es una subsecuencia incremental desde elemento } a_i \text{ de } S\] 
  \[ \text{Sea } K \in \mathbb{N}^{+}\{0\} K \in [n;|S|]\] 
  \[ P_k(S) \text{ representa los subconjuntos con tamaño } \in [0;k]\] 
  \textbf{Estado inicial:} \\
  \[ 1) (0,n,{\phi }) \] 
  \textbf{Estado:} \\
  \[ 2) (k,n,P_k(S)) \] 
  \[ \text{es final si } k == n+1 \rightarrow s_f=(n+1,n,P_n(S))\]
  \textbf{Invariante:} \\
  \[ 3) Inv(k,n,P_k(S)) \equiv k < = n+1 \land |P_K(S)<=|2^k|\] \\
  \textbf{Transformar:} \\
  \[ 4) Tran(k,n,P_k(S)) = (k+1,n,P_k(S)\cup P_{k+1}(S))\] \\
  \textbf{Demostracion: } \\
  \begin{enumerate}
    \item $Inv (S_0)$ se cumple, pues $0<= n+1$ $\land$ $P_0(S) = \{\phi\}$ $\rightarrow$ $|P_0(S)| = 1 <= 2^0 = 1$
    \item $(s_k \neq s_f \land Inv(s_k)) \rightarrow Inv(tranformar(s_k))$
    \[\equiv\]
    \[ k \neq n+1 \land k <= k+1 \land P_k(S) <= 2^k \rightarrow k+1 <= n+1 \land ...\]
    \[ ... P_{k+1}(S)< 2^{k+1} \rightarrow P_{k+1}(S) = \bigcup_{0<i}^{k}P_k \cup P_{k+1}\] 
    \[ \text{Por tanto, } Inv(tranformar(s_k)) \text{ se cumple.} \]
    \item $Inv(S_f) \rightarrow |P_n(S)| <= 2^n \equiv Inv(n+1,n,P_n(S))$
    \[\rightarrow n+1 <= n+1 \land |P_n(S)|<= 2^n \rightarrow P_n(S)\]
    \[ true \land true \rightarrow P_n(S)\]
    \item En cada paso se aumenta $k$ en una unidad hasta superar la condicion de $n$. por tanto cada vez estaria mas cerca de $n+1$ en cada iteracion se unen los subconjuntos tal que sus elementos son crecientes y acotados por una cantidad $2^k$
  \end{enumerate}
  \textbf{Casos de prueba: \\}
\begin{lstlisting}[caption=Casos de prueba para la función subindices, label=lst:scala_code]
  subindices(1, 5)
  subindices(3, 6)
  subindices(0, 4)
  subindices(2, 7)
  subindices(4, 8)
\end{lstlisting}
\begin{enumerate}
  \item \textbf{Valor esperado}: HashSet(List(1), List(1, 2, 3), List(1, 3), List(3), List(), List(2, 3), List(1, 4), List(1, 3, 4), List(1, 2), List(2, 3, 4), List(3, 4), List(4), List(2), List(2, 4), List(1, 2, 3, 4), List(1, 2, 4))
  \item \textbf{Valor esperado}: HashSet(List(4, 5), List(3), List(), List(3, 5), List(5), List(3, 4, 5), List(3, 4), List(4))
  \item \textbf{Valor esperado}: HashSet(List(1, 2, 3), List(0, 1, 2, 3), List(0, 3), List(3), List(2, 3), List(0, 1), List(1, 2), List(0, 2), List(0), List(2), List(0, 1, 3), List(1), List(1, 3), List(0, 2, 3), List(0, 1, 2), List())
  \item \textbf{Valor esperado}: HashSet(List(3, 5, 6), List(2, 3, 5, 6), List(5, 6), List(4, 5), List(), List(2, 3), List(2, 3, 5), List(3, 5), List(3, 6), List(3, 4), List(2, 3, 6), List(2), List(2, 4), List(4, 6), List(2, 4, 5), List(2, 3, 4, 5), List(2, 3, 4, 5, 6), List(3), List(3, 4, 5, 6), List(2, 3, 4, 6), List(2, 5, 6), List(4, 5, 6), List(5), List(6), List(2, 4, 6), List(3, 4, 6), List(3, 4, 5), List(2, 3, 4), List(2, 5), List(2, 6), List(2, 4, 5, 6), List(4))
  \item \textbf{Valor esperado}: HashSet(List(4, 5, 7), List(4, 6, 7), List(5, 6), List(4, 5), List(), List(5, 7), List(4, 5, 6), List(6, 7), List(4), List(5, 6, 7), List(4, 7), List(4, 5, 6, 7), List(4, 6), List(7), List(5), List(6))
\end{enumerate}

\subsection{Generación de todas las subsecuencias de una secuencia}
\subsubsection{Informe de uso de colecciones y expresiones for}
\begin{lstlisting}[caption=Código en Scala para la funcion subSecuenciaAsoc, label=lst:scala_code]
  def subSecuenciaAsoc(s:Secuencia, inds:Seq[Int]): Subsecuencia = 
      (for i <- 0 to inds.size-1 yield s(inds(i))).toList
      \end{lstlisting}
      \begin{lstlisting}[caption=Código en Scala para la funcion subSecuenciasDe, label=lst:scala_code]
  def subSecuenciasDe(s:Secuencia): Set[Subsecuencia] ={
    val combinationIndex = subindices(0, s.size) 
    for index <- combinationIndex yield subSecuenciaAsoc(s, index)
  }
            \end{lstlisting}
\begin{table}[H]
    \scriptsize
   \begin{tabular}{ |p{4cm}|p{3cm}|p{5.5cm}|  }
    \hline
    \multicolumn{3}{|c|}{Tabla $subSecuenciaAsoc$ y $subSecuenciasDe$} \\
    \hline
    \textbf{Función}& ¿Se utilizó colecciones y expresiones for?  & ¿Razón?\\
    \hline
    $subSecuenciaAsoc$ & Sí &  
      \textbf{Colecciones en Scala:} 
      \begin{itemize}
          \item \texttt{Seq} representa una secuencia de elementos en Scala. En esta función, se utiliza para representar una secuencia de índices.
          \item \texttt{toList} convierte una colección en una lista. Esto puede ser útil para garantizar un tipo de salida específico o para realizar operaciones específicas de las listas.
      \end{itemize}
      
       \textbf{Expresiones \texttt{for}:} 
      \begin{itemize}
          \item La expresión \texttt{for} se utiliza para iterar sobre la secuencia de índices y extraer los elementos correspondientes de la secuencia \texttt{s}.
          \item Facilita la generación de una nueva colección basada en otra, en este caso, una subsecuencia basada en índices específicos.
      \end{itemize}
  \\
     \hline

    
    $subSecuenciasDe$ & Sí &  
       \textbf{Uso de Funciones Preexistentes:}
      \begin{itemize}
          \item La función \texttt{subindices} se utiliza para obtener todas las combinaciones posibles de índices para una secuencia dada. Esto demuestra la reutilización de código y la composición de funciones en Scala.
      \end{itemize}
      
       \textbf{Generación de Subsecuencias:}
      \begin{itemize}
          \item La expresión \texttt{for} se utiliza para iterar sobre cada combinación de índices y generar la subsecuencia correspondiente utilizando la función \texttt{subSecuenciaAsoc}.
      \end{itemize}
      \\ \hline
   \end{tabular}
   
   \centering
   \caption{Tabla de uso de colecciones y expresiones for en la función $subSecuenciaAsoc$ y $subSecuenciasDe$}
   \end{table}

\subsubsection{Informe de corrección}
\textbf{Argumentación sobre la corrección: \\}
\textbf{subSecuenciasAsoc: } \\
\[ \text{Sea } S =<a_1,...,a_i,...,a_n> \text{ e } I=<b_1,...,b_k,...,b_r>\text{ tal que i,k,n,r} \in \mathbb{N}^{+} \]
\[ \land 0 \leqslant i \leqslant n~ 0 \leqslant k \leqslant r \land~ 0 \leqslant r \leqslant \text{, dos secuencias de modo que $I$ representa los indices ... }\]
\[\text{de $a_i \in S\{a_n\}$ de los cuales se va a extraer sus respectivos valores.}\]

\textbf{Estado:}
\[ 1) S=(k,n,r,S_k,I) \]
\begin{itemize}
  \item Numero de indice actual en $I$ tal que $a_{bi}$ es el elemento a extraer.
  \item $n$,$r$ tamanio de la secuencia de estados y de indices respectivamenteamentemente.
  \item $S_k$ la secuencia tal $S_k = <a_{b},...,a_k>$
\end{itemize}


\textbf{Estado inicial:}
\[ 2) S_0 =(0,n,r,\{\phi\},I) \qquad S_f=(r+1,n,r,[a_{b1},...,a_{br}],I) \]


\textbf{Invariante:}
\[ 3) \text{Inv}(k,n,r,S_k,I) \equiv k \leq r+1 \land r < n \land |S_k| = l \land S_k =<a_{b1},...,a_{bk}>\]

\textbf{Transformar:}
\[ 4) \text{Tran}(k,n,r,S_k,I) = (k+1,n,r,S_k \cup \{a_{b_{k+1}}\},I) \]

\textbf{Demostración:}

\begin{enumerate}
  \item $Inv(S_0)$, se cumple. Se tiene $0 < r+1 \land r<n \land |\{\phi\}|=0$ 
  \item \( (S_k \neq S_f \land \text{Inv}(S_k)) \rightarrow \text{Inv}(\text{transformar}(S_k)) \)
  \[\equiv\]
  \[k\leq r+1 \land r < n \land |S_k|=k \rightarrow k+1 \leq r+1 \land r <Mn \land |S_{k+1}|=k+1\]
  \[ \text{Ya que } S_k =<a_{bi},...,a_{bk}>\]
  \[ \rightarrow\]
  \[ (S_k \neq S_f \land Inv(S_k)) \rightarrow Inv(Tran(S_k))\]
  \item \( \text{Inv}(S_f) \rightarrow S_r =<a_{b1},...,a_{br}>\land |Sr|=r\)
  \[ \equiv\]

  \[Inv(r+1,n,r,S_r,I) \rightarrow r+1 \leq r+1 \land r<n \land |S_r| = r \land S_k = <a_{i1},...,a_{r}> \]
  \[ \equiv \]
  \[ true \land true\land true \land true \equiv true\]
  \item Cada paso de iteracion converge a $r$, lo cual implica la extraccion de r elemento $a_i$ de $S$, por tanto la subsequencia de $r$ elementos incrementales de $S$ es:
  \[ S_k =<a_{b1},...,a_{br}> |  i \leq b_i \leq n-1 \land a_{bi}\in S_i\]
\end{enumerate}

  \textbf{subSecuenciasDe: } \\
  \[ \text{Sea } S =<a_1,...,a_i,...,a_n> \text{ tal que k,n,i} \in \mathbb{N}^{+} \]
  \[ \text{Sea } SA \text{ la funcion demostrada anteriormente (subsecuenciasAsoc)}  \]
  \[ \text{Sea } Si(i,n) \text{ la funcion demostrada anteriormente (subindices)}  \]
  \[ \text{Sea } D_s(S) \text{ como la funcion que devuelve todas las posibles subsecuencias de }S\]
  \[\text{Primero se define la aplicacion de } s_i \text{ sobre  los extremos $1-n$ de la secuencia } S\]
  \[ SI (1,n) = \{e | e \in D(n)\} \text{, donde $P(n)$ define el conjunto potencia sobre los n primero numeros}\]
  \[ \text{ $N$, es decir } \]
  \[ i \leq n \land |P(n)| = m\]
  \[ \text{Llamemos $SI_k \in SI(1,n) | 1 \leq l \leq m$, el $k-esimo$ elemento de $SI_k$}\]  
  \textbf{Estado:}
  \[ 1) S=(k,m,SI_k,LC,S) \]
  \begin{itemize}
    \item $S$ La secuencia original que genera todas sus posibles subsecuencias.
    \item Donde $k$ representa el $k-esimo$ elemento asociado a $SI$.
    \item $m$ el tamaño de $SI$.
    \item $SI_k$ representa el $k-esimo$ conjunto de indices posibles de $SI$.
    \item $LC$ representa el resultado de la aplicacion $SA(S,SI_k)$ para extraer los elementos correspondientes a los $SI_k$ indices.
  \end{itemize}
    
  \textbf{Estado inicial:}
  \[ 2) S_0 =(0,m,SI_0,\{\phi\},S) \qquad S_f=(m+1,m,SI,[SA(S,SI_1),...,SA(S,SI_{m-1})],S) \]
  
  
  \textbf{Invariante:}
  \[ 3) \text{Inv}(k,m,SI_k,LC,S) \equiv k \leq m+1 \land LC  =[SA(S,SI_1),...,SA(S,SI_{m-1})] \]
  
  \textbf{Transformar:}
  \[ 4) \text{Tran}(k,m,SI_k,LC,S) \rightarrow (k+1,m,SI_{k+1},LC \cup SA(S,SI_{k+1}),S) \]
  
  \textbf{Demostración:}
  
  \begin{enumerate}
    \item $Inv(S_0)$, se cumple, puesto que $(0,m,SI_0,[\phi])$ 
    \item \( (S_k \neq S_f \land \text{Inv}(S_k)) \rightarrow \text{Inv}(\text{transformar}(S_k)) \)
    \[\equiv\]
    \[k \leq m+1 \land LC  =[SA(S,SI_1),...,SA(S,SI_{k})]\] 
    \[\rightarrow   \]
    \[k+1\leq m+1 \land LC =[SA(S,SI_1),...,SA(S,SI_{k+1})]\]
    \[ \text{Puesto que $LC$ representa un subconjunto asociado a las $k$ posibilidades de}\]
    \[ \text{seleccion de indices, se tiene:}\]
    \[ (S_k \neq S_f \land Inv(S_k)) \rightarrow Inv(Tran(S_k))\]
    \item \( \text{Inv}(S_f) \rightarrow m+1 \leq m+1 \land LC = [SA(S,SI_1),...,SA(S,SI_{m-1})]\)
    \[ \equiv\]
    \[ true  \rightarrow true \land true\] 
    \[\equiv true\]
\end{enumerate}
\textbf{Casos de prueba: \\}
\begin{lstlisting}[caption=Casos de prueba para la función subSecuenciaAsoc, label=lst:scala_code]
  val s1 = Seq(5, 25, 35, 45, 55, 65, 75)
  subSecuenciaAsoc(s1, Seq())
  subSecuenciaAsoc(s1, Seq(0, 2, 4))
  subSecuenciaAsoc(s1, Seq(1, 2, 4, 6))
  subSecuenciaAsoc(s1, Seq(0, 3, 5))
  subSecuenciaAsoc(s1, Seq(2, 3, 4, 5))
\end{lstlisting}
\begin{enumerate}
  \item \textbf{Valor esperado}: List()
  \item \textbf{Valor esperado}: List(5, 35, 55)
  \item \textbf{Valor esperado}: List(25, 35, 55, 75)
  \item \textbf{Valor esperado}: List(5, 45, 65)
  \item \textbf{Valor esperado}: List(35, 45, 55, 65)
\end{enumerate}
\begin{lstlisting}[caption=Casos de prueba para la función subSecuenciasDe, label=lst:scala_code]
  val s2 = Seq(20, 30, 10)
  subSecuenciasDe(s2)  
  val s3 = Seq(10, 20)
  subSecuenciasDe(s3)  
  val s4 = Seq(5, 15, 25, 35)
  subSecuenciasDe(s4)  
  val s5 = Seq(1, 2, 3, 4, 5)
  subSecuenciasDe(s5)  
  val s6 = Seq(50, 60, 70, 80, 90, 100)
  subSecuenciasDe(s6)  
\end{lstlisting}
\begin{enumerate}
  \item \textbf{Valor esperado} (line 2): HashSet(List(30), List(20, 30, 10), List(30, 10), List(20), List(10), List(20, 30), List(20, 10), List())
  \item \textbf{Valor esperado} (line 4): Set(List(), List(10), List(20), List(10, 20))
  \item \textbf{Valor esperado} (line 6): HashSet(List(5, 15, 25, 35), List(), List(5, 15, 35), List(15, 35), List(5, 25, 35), List(15, 25, 35), List(25), List(35), List(15, 25), List(15), List(5, 35), List(5, 15), List(5), List(25, 35), List(5, 25), List(5, 15, 25))
  \item \textbf{Valor esperado} (line 8): HashSet(List(1), List(1, 2, 3), List(1, 3), List(3, 4), List(4), List(2), List(1, 2, 3, 4), List(1, 2, 4), List(1, 2, 3, 4, 5), List(1, 2, 3, 5), List(1, 4, 5), List(4, 5), List(1, 3, 4, 5), List(2, 4, 5), List(2, 3, 4, 5), List(3), List(1, 5), List(), List(1, 2, 4, 5), List(2, 3), List(2, 3, 5), List(1, 4), List(1, 3, 4), List(3, 5), List(1, 2), List(1, 2, 5), List(5), List(3, 4, 5), List(2, 3, 4), List(2, 5), List(1, 3, 5), List(2, 4))
  \item \textbf{Valor esperado} (line 10): HashSet(List(50, 60, 70), List(70), List(60, 80, 90), List(50, 60, 80, 90, 100), List(50, 70), List(60, 70, 80), List(100), List(50, 90, 100), List(50, 60, 90), List(90), List(60, 100), List(80, 90, 100), List(60, 70, 100), List(50, 80, 100), List(70, 100), List(50, 60, 70, 90, 100), List(50, 80, 90, 100), List(50, 60), List(50, 100), List(50, 70, 80, 90), List(50, 60, 100), List(50, 70, 90, 100), List(50, 60, 70, 80, 100), List(60, 70, 80, 90), List(60, 80), List(80, 100), List(70, 90, 100), List(50, 70, 80, 100), List(60, 70, 90, 100), List(60, 90), List(60, 80, 90, 100), List(50, 70, 100), List(80), List(60, 90, 100), List(), List(50, 60, 70, 90), List(50, 60, 70, 80, 90, 100), List(70, 80, 90, 100), List(50, 60, 80, 100), List(50, 60, 80), List(80, 90), List(60, 70, 80, 100), List(60, 70), List(50, 70, 80, 90, 100), List(90, 100), List(70, 80, 100), List(60, 80, 100), List(50, 70, 80), List(50, 80), List(60, 70, 90), List(50, 60, 
  70, 80, 90), List(70, 90), List(60, 70, 80, 90, 100), List(50, 80, 90), List(50), List(60), List(50, 60, 80, 90), List(70, 80), List(50, 90), List(50, 60, 70, 80), List(50, 60, 70, 100), List(50, 60, 90, 100), List(50, 70, 90), List(70, 80, 90))
\end{enumerate}

\subsection{Generación de todas las subsecuencias incrementales de una secuencia}
\subsubsection{Informe de uso de colecciones y expresiones for}
\begin{lstlisting}[caption=Código en Scala para la funcion incremental, label=lst:scala_code]
  def incremental(seq: Subsecuencia): Boolean = seq match {
    case Nil => true
    case _ => (for index <- 1 to (seq.size - 1) yield  seq(index - 1) < seq(index)) forall( x => x)
  }
            \end{lstlisting}
  \begin{lstlisting}[caption=Código en Scala para la funcion subSecuenciasInc, label=lst:scala_code]
  def subSecuenciasInc(seq: Secuencia): Set[Subsecuencia] = 
    (for subsequence <- subSecuenciasDe(seq) if incremental(subsequence) yield subsequence).toSet
              \end{lstlisting}
\begin{table}[H]
    \scriptsize
   \begin{tabular}{ |p{4cm}|p{3cm}|p{5.5cm}|  }
    \hline
    \multicolumn{3}{|c|}{Tabla $incremental$ y $subSecuenciasInc$} \\
    \hline
    \textbf{Función}& ¿Se utilizó colecciones y expresiones for?  & ¿Razón?\\
    \hline
     $incremental$ & Sí &  
       \textbf{Pattern Matching:}
      \begin{itemize}
          \item El pattern matching es una característica poderosa de Scala que permite descomponer y verificar estructuras de datos. En este caso, se utiliza para manejar dos escenarios: cuando la subsecuencia es vacía (representada por `Nil`) y cuando no lo es.
      \end{itemize}
      
       \textbf{Verificación Incremental:}
      \begin{itemize}
          \item La expresión \texttt{for} se utiliza para iterar sobre la subsecuencia y verificar si cada elemento es menor que el siguiente. Esto genera una colección de valores booleanos.
          \item La función \texttt{forall} se utiliza para verificar que todos los valores en la colección booleana sean \texttt{true}, lo que indica que la subsecuencia es incremental.
      \end{itemize}
   \\
     \hline
     $subSecuenciasInc$ & Sí &  
       \textbf{Generación y Filtrado de Subsecuencias:}
      \begin{itemize}
          \item La función \texttt{subSecuenciasDe} se utiliza para generar todas las posibles subsecuencias de la secuencia dada.
          \item La cláusula \texttt{if incremental(subsequence)} dentro de la expresión \texttt{for} filtra las subsecuencias, conservando solo aquellas que son incrementales. Esto demuestra cómo Scala permite combinar la generación y el filtrado de colecciones de manera concisa.
      \end{itemize}
      
       \textbf{Conversión a Conjunto:}
      \begin{itemize}
          \item \texttt{toSet} convierte la colección resultante en un conjunto, eliminando posibles duplicados y garantizando la unicidad de las subsecuencias.
      \end{itemize}
  \\
     \hline
   \end{tabular}
   \centering
   \caption{Tabla de uso de colecciones y expresiones for en la función $incremental$ y $subSecuenciasInc$}
   \end{table}

\subsubsection{Informe de corrección}
\textbf{Argumentación sobre la corrección: \\}
\textbf{incremental: } \\
\[ \text{Sea } seq \text{ una subsecuencia de números naturales.} \]

\[ \text{Sea } S = \{a_1, a_2, ..., a_n\} \text{ donde } n = seq.size \text{ y } a_i \text{ es el } i\text{-ésimo elemento de }seq. \]

\[ \text{El objetivo del algoritmo es determinar si la subsecuencia es incremental, es decir,}\] 
\[ \text{si } a_i < a_{i+1} \text{ para todo } i \text{ en } [1, n-1]. \]

\textbf{Estado inicial:}
\[ 1) (1, \text{seq}, \text{true}) \]

\textbf{Estado:}
\[ 2) (i, \text{seq}, \text{true/false}) \]
\[ \text{es final si } i = n \rightarrow s_f = (n, \text{seq}, \text{true/false}) \]

\textbf{Invariante:}
\[ 3) \text{Inv}(i, \text{seq}, \text{true/false}) \equiv i \leq n \land (a_{i-1} < a_i \text{ implica true, de lo contrario false}) \]

\textbf{Transformar:}
\[ 4) \text{Tran}(i, \text{seq}, \text{true/false}) = (i+1, \text{seq}, \text{true/false según la comparación de } a_{i} \text{ y } a_{i+1}) \]

\textbf{Demostración:}

\begin{enumerate}
  \item \( \text{Inv}(S_0) \) se cumple, pues \( 1 \leq n \) y no hay elementos anteriores a \( a_1 \) para comparar, por lo que el valor inicial es verdadero.
  \item \( (s_k \neq s_f \land \text{Inv}(s_k)) \rightarrow \text{Inv}(\text{transformar}(s_k)) \)
  \[\equiv\]
  \( i \neq n \land i \leq n \land (a_{i-1} < a_i \text{ implica true, de lo contrario false}) \rightarrow i+1 \leq n \land (a_i < a_{i+1} \text{ implica true, de lo contrario false}) \)
  \[ \text{Por tanto, } \text{Inv}(\text{transformar}(s_k)) \text{ se cumple.} \]
  \item \( \text{Inv}(S_f) \rightarrow (a_{n-1} < a_n \text{ implica true, de lo contrario false}) \)
  \[\rightarrow n \leq n \land (a_{n-1} < a_n \text{ implica true, de lo contrario false}) \]
  \[ \text{true} \land \text{true/false según la comparación de } a_{n-1} \text{ y } a_n \]
  \item En cada paso, se aumenta \( i \) en una unidad hasta alcanzar \( n \). En cada iteración, se verifica si el elemento actual es mayor que el anterior y se actualiza el valor de verdad según el resultado de la comparación.
\end{enumerate}
\textbf{subSecuenciasInc: } \\
\[ \text{Sea } \text{seq} \text{ una secuencia de números naturales.} \]

\[ \text{El objetivo del algoritmo es determinar todas las subsecuencias incrementales de } \text{seq}. \]

\textbf{Estado inicial:}
\[ 1) (0, \text{seq}, \{\phi\}) \]

\textbf{Estado:}
\[ 2) (i, \text{seq}, \text{subSecuencias}) \]
\[ \text{es final si } i = \text{seq.size} \rightarrow s_f = (\text{seq.size}, \text{seq}, \text{subSecuencias}) \]

\textbf{Invariante:}
\[ 3) \text{Inv}(i, \text{seq}, \text{subSecuencias}) \equiv i \leq \text{seq.size} \land \text{subSecuencias} \text{ contiene todas las subsecuencias} \]
\[ \text{ incrementales de } \text{seq} \text{ hasta el índice } i \]

\textbf{Transformar:}
\[ 4) \text{Tran}(i, \text{seq}, \text{subSecuencias}) = (i+1, \text{seq}, \text{subSecuencias} \cup \text{subSecuencia} \text{ si es incremental}) \]

\textbf{Demostración:}

\begin{enumerate}
  \item \( \text{Inv}(S_0) \) se cumple, pues \( 0 \leq \text{seq.size} \) y no hay subsecuencias para considerar en el índice 0.
  \item \( (s_k \neq s_f \land \text{Inv}(s_k)) \rightarrow \text{Inv}(\text{transformar}(s_k)) \)
  \[\equiv\]
  \( i \neq \text{seq.size} \land i \leq \text{seq.size} \land \text{subSecuencias} \text{ contiene todas las subsecuencias incrementales} \)
  \( \text{ de } \text{seq} \text{ hasta el índice } i \rightarrow i+1 \leq \text{seq.size} \land \text{subSecuencias} \text{ contiene todas las subsecuencias} \)
  \( \text{ incrementales de } \text{seq} \text{ hasta el índice } i+1 \)
  \[ \text{Por tanto, } \text{Inv}(\text{transformar}(s_k)) \text{ se cumple.} \]
  \item \( \text{Inv}(S_f) \rightarrow \text{subSecuencias} \text{ contiene todas las subsecuencias incrementales de } \text{seq} \)
  \[\rightarrow \text{seq.size} \leq \text{seq.size} \land \text{subSecuencias} \text{ contiene todas las subsecuencias incrementales de } \text{seq} \]
  \[ \text{true} \land \text{true} \]
  \item En cada paso, se aumenta \( i \) en una unidad hasta alcanzar \( \text{seq.size} \). En cada iteración, se verifica si la subsecuencia actual es incremental y, si es así, se agrega a la colección de subsecuencias incrementales.
\end{enumerate}
\textbf{Casos de prueba: \\}
\begin{lstlisting}[caption=Casos de prueba para la función incremental, label=lst:scala_code]
  val s7 = Seq(1, 2, 3, 4, 5, 6, 7)
  incremental(s7)// true
  val s8 = Seq()
  incremental(s8)//true
  val s9 = Seq(1, 1, 1, 1, 1, 1, 1)
  incremental(s9)//false
  val s10 = Seq(1, 2, 3, 5, 4, 6, 7)
  incremental(s10)//false
  val s11 = Seq(7, 6, 5, 4, 3, 2, 1)
  incremental(s11)//false
\end{lstlisting}
\begin{lstlisting}[caption=Casos de prueba para la función subSecuenciasInc, label=lst:scala_code]
  subSecuenciasInc(Seq(1, 2))
  subSecuenciasInc(Seq(5, 7, 9))
  subSecuenciasInc(Seq(2, 4, 8, 16))
  subSecuenciasInc(Seq(0, 1, 2))
  subSecuenciasInc(Seq(10, 20, 30, 40))
\end{lstlisting}
\begin{enumerate}
  \item \textbf{Valor esperado}: Set(List(), List(1), List(2), List(1, 2))
  \item \textbf{Valor esperado}: HashSet(List(5, 9), List(9), List(7), List(), List(5, 7), List(7, 9), List(5, 7, 9), List(5))
  \item \textbf{Valor esperado}: HashSet(List(8), List(16), List(4, 16), List(2, 8), List(2, 4, 16), List(4), List(2, 16), List(2, 8, 16), List(8, 16), List(4, 8, 16), List(), List(2), List(2, 4, 8, 16), List(4, 8), List(2, 4), List(2, 4, 8))
  \item \textbf{Valor esperado}: HashSet(List(1), List(0, 1), List(1, 2), List(0, 2), List(0), List(2), List(0, 1, 2), List())
  \item \textbf{Valor esperado}: HashSet(List(30, 40), List(10, 20), List(10, 40), List(20, 40), List(30), List(10, 30, 40), List(10), List(20, 30, 40), List(20, 30), List(10, 20, 30), List(10, 30), List(), List(20), List(40), List(10, 20, 40), List(10, 20, 30, 40))
\end{enumerate}

\subsection{Hallar la subsecuencia incremental más larga}
\subsubsection{Informe de uso de colecciones y expresiones for}
\begin{lstlisting}[caption=Código en Scala para la funcion subsecuenciaIncrementalMasLarga, label=lst:scala_code]
def subsecuenciaIncrementalMasLarga(seq: Secuencia): Subsecuencia = {
  val subsequences = (for subsequence <- subSecuenciasInc(seq) if incremental(subsequence) yield subsequence).toList
  val subsequencesSizes = subsequences.map(_.size) 
  val indexOfLargestSubsequence = (subsequencesSizes.indexWhere(x => x == subsequencesSizes.max))
  indexOfLargestSubsequence match {
    case x if x < 0 => List()
    case x => subsequences(x)
  }
}
                      \end{lstlisting}
\begin{table}[H]
    \scriptsize
   \begin{tabular}{ |p{4cm}|p{3cm}|p{5.5cm}|  }
    \hline
    \multicolumn{3}{|c|}{Tabla base $subsecuenciaIncrementalMasLarga$} \\
    \hline
    \textbf{Función}& ¿Se utilizó colecciones y expresiones for?  & ¿Razón?\\
    \hline
     subsecuenciaIncremental-MasLarga & Sí &  
      \textbf{Generación y Filtrado de Subsecuencias Incrementales:}
      \begin{itemize}
          \item Se utiliza la función \texttt{subSecuenciasInc} para obtener todas las subsecuencias incrementales de la secuencia dada.
          \item Aunque \texttt{subSecuenciasInc} ya filtra las subsecuencias incrementales, la cláusula \texttt{if incremental(subsequence)} se mantiene por claridad y robustez.
      \end{itemize}
      
       \textbf{Determinación de la Subsecuencia Más Larga:}
      \begin{itemize}
          \item \texttt{map} se utiliza para transformar la lista de subsecuencias en una lista de sus tamaños.
          \item \texttt{find} se utiliza para obtener el índice de la subsecuencia más larga.
      \end{itemize}
  
       \textbf{Pattern Matching para la Salida:}
      \begin{itemize}
          \item Se utiliza pattern matching para manejar diferentes escenarios: cuando no se encuentra ninguna subsecuencia, cuando se encuentra una subsecuencia y cualquier otro caso.
      \end{itemize}
  \\
     \hline
   \end{tabular}
  
   \centering
   \caption{Tabla de uso de colecciones y expresiones for en la función $subsecuenciaIncrementalMasLarga$}

   \end{table}
\subsubsection{Informe de corrección}
\textbf{Argumentación sobre la corrección: \\}

\[ \text{Sea } S =<a_1,...,a_i,...,a_n> | 1 \leq i \leq n  \in \mathbb{N}^{+} \text{una secuencia } \]
\[ \text{Sea } Inc(S) \text{ una funcion predicado que determina si $S$ es incremental}  \]
\[ \text{Sea } SInc(S)) \text{ la funcion que retorna el conjunto de las subsequiencias incrementales de $S$}  \]
\[ \text{Sea }k| k \leq m \text{ donde $|SInc(S)| =m$, es la cantidad de subsecuencias de $S$ }\]
\[ \text{Sea }SInc_k \text{ la $k-esima$ subsecuencia incremental de $SInc$ }\]

\textbf{Estado:}
\[ 1) S=(k,m,SInc_k,Inc,S) \]
\begin{itemize}
  \item $k$ elemento de $SInc$.
  \item $m$ el tamaño de conjunto $SInc$.
  \item $SInc_k$ la $k-esima$ subsecuencia incremental de $SInc_k$.
  \item $Inc$ conjunto que colecciona las $k$ subsecuencias determinadas hasta entonces.
  \item $S$ la secuencia original.
\end{itemize}
  
\textbf{Estado inicial:}
\[ 2) S_0 =(0,m,\{\phi\},\{\phi\},S) \qquad S_f=(m+1,m,\{\phi\},Inc_n,S) | Inc_n = [SInc_1,...,SInc_m] \]


\textbf{Invariante:}
\[ 3) \text{Inv}(S_k) \equiv k \leq m+1 \land Inc_k  =[SInc_1,...,SInc_k] \]

\textbf{Transformar:}
\[ 4) \text{Tran}(k,m,SInc_k,Inc,S) \rightarrow (k+1,m,SInc_{k+1},Inc \cup SInc_k,S) \]

\textbf{Demostración:}

\begin{enumerate}
  \item $Inv(S_0)$, se cumple, puesto que $(0,m,[\phi],[\phi],S)$ 
  \item \( (S_k \neq S_f \land \text{Inv}(S_k)) \rightarrow \text{Inv}(\text{transformar}(S_k)) \)
  \[\equiv\]
  \[k \leq m+1 \land Inc_k  =[SInc_1,...,SInc_k]\] 
  \[\rightarrow   \]
  \[k+1\leq m+1 \land Inc \cup SInc_{k+1}\]
  \[ \text{Puesto que $Inc_{k+1}=\bigcup_{1\leq i \leq k } SInc_i \cup Inc_{k+1}$ }\]
  \[ \text{Se tiene:}\]
  \[ (S_k \neq S_f \land Inv(S_k)) \rightarrow Inv(Tran(S_k))\]
  \item \( \text{Inv}(S_f) \rightarrow m+1 \leq m+1 \land Inc_n \equiv Inc \)
  \[\text{donde $Inc$ representa todas las posibles combinaciones incrementales de }S\]
  \[ \equiv\]
  \[ true  \rightarrow true \land true\] 
  \[\equiv true\]
\end{enumerate}
Hasta aqui, se ha determinado todas las posibles subsequiencias de $S$, ahora la subsecuencia mas larga. Sea $Size(z)$ una funcion que aplica una transformacion de cada $SInc_k$ a su respectivo tamaño.
$Size(Inc)=\{x|x = |Inc_k|\}$. \\
Sea la funcion $max(S)$ que determina el mayor valor del elemento de $S$ y sea $find(e,N)$ una funcion que devuelve un resultado opcional si se cumple l predicado $p$ sobre un elemento $n \in N$ secuencia.
\\ 
$\rightarrow$ $find(max(size(Inc)),Inc)$ da la subsecuencia mas larga en los elementos de $Inc$. \\
\newpage
\textbf{Casos de prueba: \\}
\begin{lstlisting}[caption=Casos de prueba para la función subsecuenciaIncrementalMasLarga, label=lst:scala_code]
  val s14 = Seq(1, 2, 3, 4, 5)
  subsecuenciaIncrementalMasLarga(s14) //List(1, 2, 3, 4, 5)
  val s15 = Seq(5, 10, 15, 14, 13, 12)
  subsecuenciaIncrementalMasLarga(s15) //List(5, 10, 14)
  val s16 = Seq(2, 4, 8, 7, 6, 5)
  subsecuenciaIncrementalMasLarga(s16) //List(2, 4, 7)
  val s17 = Seq(0, 1, 1, 2, 3, 5, 4)
  subsecuenciaIncrementalMasLarga(s17) //List(0, 1, 2, 3, 5)
  val s18 = Seq(10, 20, 30, 25, 35, 45)
  subsecuenciaIncrementalMasLarga(s18) //List(10, 20, 30, 35, 45)
\end{lstlisting}

\section{Hacia una solución más eficiente}
\subsection{Calculando $SIML_i(S)$}
\subsubsection{Informe de uso de colecciones y expresiones for}
\begin{lstlisting}[caption=Código en Scala para la funcion sssimlComenzandoEn, label=lst:scala_code]
def sssimlComenzandoEn(i: Int, seq: Secuencia): Subsecuencia = {
      
  def sssimlHelper(r: Int, seq: Secuencia, subsequence: Subsecuencia, maxValueOfSubsequence: Int): Subsecuencia = {
    r match {
        case r if seq.size == r => subsequence
        case r => {
          val isLargestValue = seq(r) > maxValueOfSubsequence
          sssimlHelper(
          r + 1, 
          seq, 
          if (isLargestValue) subsequence ++ List(seq(r)) else subsequence, 
          if (isLargestValue) seq(r) else maxValueOfSubsequence)
        }
    }
  }

  val subsequences = (
    for{ k <- i until seq.size 
          j <- k  until seq.size
          subsequence = sssimlHelper(j, seq, List(seq(k)), seq(k))
  } yield {
    subsequence}).toList
  val subsequencesMaxSize = subsequences.map(_.size).max
  subsequences.find(x => x.size == subsequencesMaxSize) match {
    case None => List() 
    case Some(x) => x
  }
}
                        \end{lstlisting}
\begin{table}[H]
    \scriptsize
   \begin{tabular}{ |p{4cm}|p{3cm}|p{5.5cm}|  }
    \hline
    \multicolumn{3}{|c|}{Tabla base completar} \\
    \hline
    \textbf{Función}& ¿Se utilizó colecciones y expresiones for?  & ¿Razón?\\
    \hline
    $ssimlComenzandoEn$ & Si &  
    
       \textbf{Generación de Subsecuencias}: La expresión \texttt{for} permite iterar sobre la secuencia de entrada y generar todas las posibles subsecuencias incrementales que comienzan en el índice \(i\). Esta estructura proporciona una forma concisa y eficiente de generar subsecuencias.
      
      \textbf{Filtrado y Búsqueda}: Las colecciones en Scala ofrecen métodos como \texttt{map}, \texttt{max} y \texttt{find} que se utilizan en el algoritmo para filtrar y buscar la subsecuencia deseada.
      
       \textbf{Recursividad y Colecciones}: La función auxiliar \texttt{sssimlHelper} utiliza recursividad para construir la subsecuencia incremental. Las colecciones facilitan la construcción y el paso de subsecuencias a través de llamadas recursivas.
   \\
     \hline
   \end{tabular}
   \centering
   \caption{Tabla de uso de colecciones y expresiones for en la función $ssimlComenzandoEn$}
   \end{table}
\subsubsection{Informe de corrección}
\textbf{Argumentación sobre la corrección: \\}
la funcion $sssimlComenzandoEn$ devuelve la secuencia $S_i$ mas larga de la secuencia $S$ desde el 
    indice $i$; hace uso de una expresion $for$ la cual genera un producto cartesiano $k$x$j$, donde $k$ representa
    las lista original sin los k primeros elementos, y $j$ el recorrido desde $k$ hasta el tamaño $n$ de la subsecuencia de
    tamaño $n - k$. Dentro de la expresion $for$ se llama para cada combinacion $(k,j)$ la funcion $sssimlHelper$,
    que recibe el parametro $j$ actual, la secuencia original, la subsecuencia de los valores que han sido incrementales en sus anteriores iteraciones, y
    el ultimo valor mas grande e incremental encontrado. Dentro, tiene las condicion de parada si se ha alcanzado el tamaño de la 
    secuencia original; de lo contrario, se aplica el predicado que determina si el valor actual de la secuencia $seq(r)$ en $r$ supera en valor 
    númerico al ultimo valor incremental $maxValueOfSubsequence$; si ello se cumple, el proximo llamado recursivo a 
    $sssimlHelper$ sera con este nuevo valor determinado addicionado a $subsecuencia$ y $maxValueOfSubsequence$ actualizado a dicho valor 
con la logica de detrminacion de termino incrementales de la subsecuencia implicada para el indice $t$. Si el predicado no se cumple,
   se incrementa $r$ en uno para que tienda a $seq.size$ y seguir el proceso sin modificar la $subsecuence$ hasta el paso el paso $r$

   Este proceso lo hace iterativamente para cada $k$ donde $ i \leq k \leq n$.
   Al final del paso anterior, donde se cumple las invariantes de $ k \leq seq.size \land k \leq  j \leq seq.size$, se tiene 
   que $subsequences$ es el conjunto de todas las posibles subsecuencias incrementales de $seq$ desde  $i$ hasta $seq.size$

   Al anterior resultado le aaplicamos un transformacion $Size(subsequences)$ a cada elemento de $subsequences$ para obtener
   el tamaño de cada subsecuencia incrementales de $seq$. Entonces se usa la funcion $max(Size(subsequences))$ para determinar
   cual de estas secuencias incrementales tiene mayor numero de elementos, que es el interes ultimo de este algoritmo.
   El resultado de $max$ devuelve un valor que a posteriori sera utilizazo como algumento de la funcion $find$, la cual toma como
   argumento un predicado $p$ y una secuencia a la cual aplicar el predicado. En particular, el predicado determina el
   primer elemento dentro de $subsequences$ tal que su valor se corresponda al valor maximo determinado.
   La ultima instruccion es un match pattern sobre el resultado de $find$, funcion que retorna el resultado en un contexto computacional,
   la monada $Optional$, el cual permite manejar la ausencia y presencia de un valor de forma natural y sin errores inesperados.
   Por tanto, la expresion de match pattern permite desenvolver el valor correspondiente a  la subsecuencia mas larga dentor de $seq$ desde $i$,
   y retornala como el valor retorno de $sssimlComenzandoEn$. Esto demuestra, la correctitud de la implementacion de la funcion. \\
\textbf{Casos de prueba: \\}
\begin{lstlisting}[caption=Casos de prueba para la función sssimlComenzandoEn, label=lst:scala_code]
  sssimlComenzandoEn(0, Seq(10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11))
  // List(10, 22)
  sssimlComenzandoEn(5, Seq(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
  //List(6, 7, 8, 9, 10)
  sssimlComenzandoEn(3, Seq(5, 6, 7, 1, 2, 3, 4, 8, 9, 10)) 
  //List(1, 2, 3, 4, 8, 9, 10)
  sssimlComenzandoEn(2, Seq(10, 20, 5, 15, 25, 35, 45)) 
  //List(5, 15, 25, 35, 45)
  sssimlComenzandoEn(4, Seq(2, 4, 6, 8, 1, 3, 5, 7, 9))
  //List(1, 3, 5, 7, 9)
  sssimlComenzandoEn(1, Seq(5, 1, 2, 3, 4, 6, 7, 8, 9, 10))
  //List(1, 2, 3, 4, 6, 7, 8, 9, 10)
\end{lstlisting}

\subsection{Calculando una subsecuencia incremental más larga, versión 2}
\subsubsection{Informe de uso de colecciones y expresiones for}
\begin{lstlisting}[caption=Código en Scala para la funcion subSecIncMasLargaV2, label=lst:scala_code]
def subSecIncMasLargaV2(sequence: Secuencia) = 
  val si = (for i <- 0 until sequence.size yield sssimlComenzandoEn(i, sequence))
  val siSizes = for j <- 0 until si.size yield si(j).size
  (si.find(x => x.size == siSizes.max)) match {
      case None => List()
      case Some(x) => x 
  }
                          \end{lstlisting}
\begin{table}[H]
    \scriptsize
   \begin{tabular}{ |p{4cm}|p{3cm}|p{5.5cm}|  }
    \hline
    \multicolumn{3}{|c|}{Tabla base completar} \\
    \hline
    \textbf{Función}& ¿Se utilizó colecciones y expresiones for?  & ¿Razón?\\
    \hline
    $subSecIncMasLargaV2$ & Si &  
       \textbf{Generación de Subsecuencias}: La primera expresión \texttt{for} itera sobre cada índice de la secuencia y utiliza la función \texttt{sssimlComenzandoEn} para generar la subsecuencia incremental más larga que comienza en ese índice. Esto resulta en una colección de subsecuencias.
  
       \textbf{Obtención de Tamaños}: La segunda expresión \texttt{for} itera sobre la colección de subsecuencias generadas y obtiene el tamaño de cada una. Esto facilita la identificación de la subsecuencia más larga en pasos posteriores.
  
       \textbf{Búsqueda de la Subsecuencia Más Larga}: Se utiliza el método \texttt{find} de las colecciones en Scala para buscar la subsecuencia con el tamaño máximo. Esta operación es eficiente y concisa gracias a las capacidades de las colecciones en Scala.
  
       \textbf{Manejo de Casos}: El uso del emparejamiento de patrones (pattern matching) con \texttt{match} permite manejar diferentes casos, como cuando no se encuentra ninguna subsecuencia o cuando se encuentra la subsecuencia deseada. Esto proporciona una forma estructurada y legible de manejar diferentes escenarios de salida.
   \\
     \hline
   \end{tabular}
   \centering
   \caption{Tabla de uso de colecciones y expresiones for en la función subSecIncMasLargaV2}
   \end{table}
\subsubsection{Informe de corrección}
\textbf{Argumentación sobre la corrección: \\}
\[ \text{Sea } \text{sequence} \text{ una secuencia de números naturales.} \]
\[ si \text{ contiene todas las subsecuencias incrementales de } \text{sequence} \text{ hasta el índice } i \]

\[ \text{El objetivo del algoritmo es determinar la subsecuencia incremental más larga de } \text{sequence}. \]

\textbf{Estado inicial:}
\[ 1) (0, \text{sequence}, \{\phi\}, \{\phi\}) \]

\textbf{Estado:}
\[ 2) (i, \text{sequence}, si, \text{siSizes}) \]
\[ \text{es final si } i = \text{sequence.size} \rightarrow s_f = (\text{sequence.size}, \text{sequence}, si, \text{siSizes}) \]

\textbf{Invariante:}
\[ 3) \text{Inv}(i, \text{sequence}, si, \text{siSizes}) \equiv i \leq \text{sequence.size} \land si \text{ contiene todas las subsecuencias} \]
\[ \text{ incrementales de } \text{sequence} \text{ hasta el índice } i \]

\textbf{Transformar:}
\[ 4) \text{Tran}(i, \text{sequence}, si, \text{siSizes}) = (i+1, \text{sequence}, si \cup \text{subSecuencia} \text{ si es incremental}, \]
\[ \text{siSizes} \cup \text{tamaño de subSecuencia}) \]

\textbf{Demostración:}

\begin{enumerate}
  \item \( \text{Inv}(S_0) \) se cumple, pues \( 0 \leq \text{sequence.size} \) y no hay subsecuencias para considerar en el índice 0.
  \item \( (s_k \neq s_f \land \text{Inv}(s_k)) \rightarrow \text{Inv}(\text{transformar}(s_k)) \)
  \[\equiv\]
  \[ i \neq \text{sequence.size} \land i \leq \text{sequence.size} \land si  \]
  \[  i \rightarrow i+1 \leq \text{sequence.size} \land si \]
  \[ \text{Por tanto, } \text{Inv}(\text{transformar}(s_k)) \text{ se cumple.} \]
  \item \[ \text{Inv}(s_f) \rightarrow si \] 

  \[\rightarrow \text{sequence.size} \leq \text{sequence.size} \land si  \]
  \[ \text{true} \land \text{true} \]
  \item En cada paso, se aumenta \( i \) en una unidad hasta alcanzar \( \text{sequence.size} \). En cada iteración, se verifica si la subsecuencia actual es incremental y, si es así, se agrega a la colección de subsecuencias incrementales y se actualiza el tamaño de la subsecuencia.
\end{enumerate}
\textbf{Casos de prueba: \\}
\begin{lstlisting}[caption=Casos de prueba para la función subSecIncMasLargaV2, label=lst:scala_code]
  subSecIncMasLargaV2(Seq())
  // List()
  subSecIncMasLargaV2(Seq(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) 
  // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
  subSecIncMasLargaV2(Seq(5, 6, 7, 1, 2, 3, 4, 8, 9, 10))  
  // List(1, 2, 3, 4, 8, 9, 10)
  subSecIncMasLargaV2(Seq(10, 20, 5, 15, 25, 35, 45))  
  // List(10, 20, 25, 35, 45)
  subSecIncMasLargaV2(Seq(2, 4, 6, 8, 1, 3, 5, 7, 9))  
  // List(2, 4, 6, 8, 9)
  subSecIncMasLargaV2(Seq(5, 1, 2, 3, 4, 6, 7, 8, 9, 10))
  // List(1, 2, 3, 4, 6, 7, 8, 9, 10)
\end{lstlisting}
\section{Conclusiones}
Los casos de prueba actuales son bastante robustos y cubren una amplia variedad de escenarios que el programa podría encontrar en la práctica. Se trata de abordar diferentes escenarios para que mientras se va desarrollando el programa/funcion se puedan encontrar errores en el proceso de solucion de este. Como bien sabemos la mejor manera de demostrar la correctitud de este tipo de algoritmos, es a través de una demostracion formal. Para estas 8 funciones que se desarrollaron en este taller,
la modalidad de demostracion que se uso fue $Induccion~Estructural$, creemos que es pertinente porque todas las funciones utilizan expresiones $for$ y colecciones de $scala$. A pesar que algunos casos de prueba nos ayudaron en el proceso de la creacion o solucion de las funciones, es practicamente imposible hacer suficientes casos de prueba para abarcar todas las posibles combinaciones de listas o sequencias que podrian entrar por parametro para estas funciones. Por lo tanto se acude a una demostracion formal para verificar su correctitud en todos los puntos del taller.
\end{document}