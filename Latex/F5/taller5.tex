\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{listings}
\usepackage{amsfonts} 
\usepackage{xcolor} 
\usepackage[margin=1in]{geometry} 
\lstset{
    language=Scala,  % lenguaje de programación
    basicstyle=\ttfamily\small,  % estilo de la fuente del código
    numbers=left,  % posición de los números de línea
    numberstyle=\tiny\color{gray},  % estilo de los números de línea
    stepnumber=1,  % el paso entre dos números de línea
    numbersep=5pt,  % cómo de lejos están los números de línea del código
    backgroundcolor=\color{white},  % color de fondo
    showspaces=false,  % mostrar espacios añadiendo particular subrayado
    showstringspaces=false,  % subrayar espacios dentro de las cadenas
    showtabs=false,  % mostrar tabs dentro de las cadenas añadiendo particular subrayado
    frame=single,  % añade un marco al código
    rulecolor=\color{black},  % si no se establece, el color del marco será el del texto
    tabsize=2,  % tamaño de los tabs
    captionpos=b,  % posición del título de la tabla (t=top, b=bottom)
    breaklines=true,  % establecer si las líneas automáticas se rompen
    breakatwhitespace=false, 
    escapeinside={\%*}{*)},  % si quieres añadir LaTeX dentro de tu código
    keywordstyle=\color{blue},  % estilo de las palabras clave
    commentstyle=\color{olive},  % estilo de los comentarios
    stringstyle=\color{violet},  % estilo de las cadenas
}
\graphicspath{ {./images/} }
\title{
  \begin{figure}[th]
    \centering
    \includegraphics[width=0.2\textwidth]{Univalle}
  \end{figure}
  \textbf{Universidad del Valle
    \\{\Large Facultad de ingeniería}
  \\{\large Ingeniería en sistemas}}}
\author{Cristian David Pacheco Torres
  \\ 2227437
  \\ Juan Sebastian Molina Cuellar
  \\ 2224491}
\date{\today}

\begin{document}
\maketitle
{Taller 4: Colecciones y Expresiones For:
\\ El problema de la subsecuencia incremental de longitud máxima}
\newpage{}

\tableofcontents
\newpage{}
\section{Introducción}
\subsection{Preliminares}
Con el proposito de implementar diferentes algoritmos de multiplicación de matrices, tanto secuenciales, recursivos y paralelos, se nos otorgó a través del \textit{Taller 5: Multiplicación de matrices en paralelo}, la definicion matemática de las siguientes operaciones:
\begin{itemize}
  \item Transpuesta de una matriz.

    \[T: \mathbb{R}^{m \times n} \to \mathbb{R}^{n \times m} \label{eq:transpuesta} \]
  \begin{equation}
    T(A) = [a_{ji}]_{n \times m}
  \end{equation}
  
  Se denota como : $\textbf{A}^T$
  \item Producto punto de vectores.
\[
    \cdot: \mathbb{R}^n \times \mathbb{R}^n \to \mathbb{R}
\]
  \begin{equation}
    \mathbf{u} \cdot \mathbf{v} = \sum_{i=1}^{n} u_i v_i
  \end{equation}
  Donde  "$\cdot$" denota la operacion binaria entre dos vectores $~\in \mathbb{R}^n$.
  \item Multiplicación de matrices.
  \begin{equation}
    C_{ij} = \sum_{k=1}^{n} A_{ik} \cdot B_{kj}
  \end{equation}
  \item Suma de matrices.
\[
    +: \mathbb{R}^{m \times n} \times \mathbb{R}^{m \times n} \to \mathbb{R}^{m \times n}
\]
\[
    A + B = C
\]
  \begin{equation}
    C_{ij} = A_{ij} + B_{ij}
  \end{equation}
  Donde "$+$" representa la operación de adición entre dos matrices $~\in \mathbb{R}^{m \times n}$.
  A y B son las matrices a sumar.
  C es la matriz resultante de la suma.
  \item Resta de matrices.
\[
    -: \mathbb{R}^{m \times n} \times \mathbb{R}^{m \times n} \to \mathbb{R}^{m \times n}
\]
  \begin{equation}
    C_{ij} = A_{ij} - B_{ij}
  \end{equation}
\[
    A - B = C
\]
\end{itemize}
\textbf{Definiciones de utilidad:}\\ \\
Sea una tarea computacional $T=(t,r)$, donde $t$ es el tiempo de ejecución y $r$ el resultado.\\
Además definase dos funciones sobre $T$ como:
\begin{equation}
     \rho(T)= \rho(t,r) = r
\end{equation}
\begin{equation}
      \phi(T)= \phi(t,r) = t
\end{equation}
Definase una computación secuencial $S$: 
\begin{equation}
    S=<T_1,T_2,...T_i,...,T_{n-1},T_{n}>
\end{equation}
Donde $i$ representa el orden de ejecución de la tarea $T_i~ |~  0 \leq i \leq n$.\\ \\
Definase una computación paralela $P$:
\begin{equation}
    P=\{T_1,T_2,...T_i,...,T_{n-1},T_{n}\}
\end{equation}
Donde $i$ identifica cada tarea que a posteriori se le extraerá el tiempo de ejecución y el resultado.\\ \\
Sea $\phi(S)$ el tiempo de ejecución de una secuencia $S$:
\begin{equation}
    \phi(S)= \sum_{1}^{n}\phi(T_i)
\end{equation}
Sea $\phi(T)$ el tiempo de ejecución del conjunto de tareas $P$:
\begin{equation}
    \phi(P)= \max (\phi_i(T_i)) ~ | ~ 1 \leq i \leq n \land \phi_i(T_i) \in P
\end{equation}
\subsection{Algoritmos de proporcionados de utilidad}
En el listing \ref{lst:scala_code1}, se definen dos tipos de datos esenciales: \texttt{Matriz} y \texttt{MatrizD}. Estos tipos representan matrices de enteros, donde \texttt{MatrizD} está diseñada para un procesamiento paralelo en base al tipo $ParVector$ de $Scala$.

\begin{lstlisting}[caption=Definiciones tipos de datos, label=lst:scala_code1]
type Matriz = Vector[Vector[Int]]
type MatrizD = ParVector[ParVector[Int]]
\end{lstlisting}
\begin{lstlisting}[caption=matriz al azar, label=lst:scala_code2]
def matrizAlAzar(long:Int, vals:Int) = {
    //Crea una matriz de enteros cuadrada de long x long,
    //con valores entre 0 y vals
    val v = Vector.fill(long, long){random.nextInt(vals)}
    v
}
\end{lstlisting}
\begin{lstlisting}[caption=vector al azar, label=lst:scala_code3]
def vectorAlAzar(long:Int, vals:Int): Vector[Int] = {
    //Crea un vector de enteros de longitud long,
    //con valores aleatorios entre 0 y vals
    val v = Vector.fill(long){random.nextInt(vals)}
    v
}
\end{lstlisting}
\begin{lstlisting}[caption=producto punto, label=lst:scala_code4]
def prodPunto(v1: Vector[Int], v2: Vector[Int]): Int = {
    //Calcula el producto punto entre dos vectores
    (v1 zip v2).map({case (i,j) => i*j}).sum
}
\end{lstlisting}
\begin{lstlisting}[caption=transpuesta de una matriz, label=lst:scala_code5]
def transpuesta(m: Matriz): Matriz = {
    //Calcula la transpuesta de una matriz
    val l =m.length
    Vector.tabulate(l,l)((i,j)=>m(j)(i))
}
\end{lstlisting}

Los algoritmos anteriores fueron sugeridos en el $Taller 5$ por parte del profesor, para la implementación de las funciones a desarrollar en este informe. Estos algoritmos fueron de utilidad para generar matrices aletorias y operaciones fundamentales entre vectores.

\section{Informe del taller - secciones}
\subsection{Informe de corrección}
\textbf{{multMatriz}} \\ \\
\begin{lstlisting}[caption=mult matriz, label=lst:scala_code6]
def multMatriz(m1: Matriz, m2: Matriz): Matriz = {
    val l = m1.length
    val m = m2.length
    val v =Vector.tabulate(l,m)((i,j)=>prodPunto(m1(i),transpuesta(m2)(j)))
    v
}
\end{lstlisting}
\textbf{{multMatrizPar}} \\ \\
\begin{lstlisting}[caption=mult matriz paralela, label=lst:scala_code7]
def multMatrizPar(m1: Matriz, m2: Matriz): Matriz = {
    val l = m1.length
    val m = m2.length
    val parRows = for (k <- 0 until l ) 
        yield {
            (k,task(Vector.tabulate(1,m)((i,j)=>
                prodPunto(m1(k),transpuesta(m2)(j)))))
        }
    val v = parRows.map({case (i,j) => 
        (i,j.join())}).sortBy(_._1).map(_._2)
    v.reduce(_++_)
}
\end{lstlisting}
\textbf{{multMatrizRec}} \\ \\
\begin{lstlisting}[caption=mult matriz recursiva, label=lst:scala_code8]
def multMatrizRec(m1:Matriz, m2:Matriz): Matriz ={
    //recibe m1 y m2 matrices cuadradas de la misma dimension, potencia de 2
    //y devuelve la multiplicacion de las 2 matrices
    val n = m1.length
    if(n == 1) {
        Vector(Vector(m1(0)(0)*m2(0)(0)))
    }
    else {
        val l = n/2
        val (m1_11, m1_12, m1_21, m1_22) = 
            (subMatriz(m1,0,0,l),subMatriz(m1,0,l,l),
             subMatriz(m1,l,0,l),subMatriz(m1,l,l,l))
        val (m2_11, m2_12, m2_21, m2_22) =
            (subMatriz(m2,0,0,l),subMatriz(m2,0,l,l),
             subMatriz(m2,l,0,l),subMatriz(m2,l,l,l))

        val c_11 = sumMatriz(multMatrizRec(m1_11,m2_11),multMatrizRec(m1_12,m2_21))
        val c_12 = sumMatriz(multMatrizRec(m1_11,m2_12),multMatrizRec(m1_12,m2_22))
        val c_21 = sumMatriz(multMatrizRec(m1_21,m2_11),multMatrizRec(m1_22,m2_21))
        val c_22 = sumMatriz(multMatrizRec(m1_21,m2_12),multMatrizRec(m1_22,m2_22))

        Vector.tabulate(n,n)((i,j)=>
            if(i<l && j<l) c_11(i)(j)
            else if(i<l && j>=l) c_12(i)(j-l)
            else if(i>=l && j<l) c_21(i-l)(j)
            else c_22(i-l)(j-l))
    }
}
\end{lstlisting}
\textbf{{multMatrizRecPar}} \\ \\
\begin{lstlisting}[caption=mult matriz recursiva paralela, label=lst:scala_code9]
def multMatrizRecPar(m1:Matriz, m2:Matriz): Matriz ={
    //recibe m1 y m2 matrices cuadradas de la misma dimension, potencia de 2
    //y devuelve la multiplicacion de las 2 matrices, paralelizando tareas
    val n = m1.length
    if(n == 1) {
        Vector(Vector(m1(0)(0)*m2(0)(0)))
    }
    else {
        val l = n/2
        val (m1_11, m1_12, m1_21, m1_22) = 
            (subMatriz(m1,0,0,l),subMatriz(m1,0,l,l),
             subMatriz(m1,l,0,l),subMatriz(m1,l,l,l))
        val (m2_11, m2_12, m2_21, m2_22) =
            (subMatriz(m2,0,0,l),subMatriz(m2,0,l,l),
             subMatriz(m2,l,0,l),subMatriz(m2,l,l,l))
        val (c_11, c_12, c_21, c_22) = parallel(
            sumMatriz(multMatrizRec(m1_11,m2_11),
                      multMatrizRec(m1_12,m2_21)),
            sumMatriz(multMatrizRec(m1_11,m2_12),
                      multMatrizRec(m1_12,m2_22)),
            sumMatriz(multMatrizRec(m1_21,m2_11),
                      multMatrizRec(m1_22,m2_21)),
            sumMatriz(multMatrizRec(m1_21,m2_12),
                      multMatrizRec(m1_22,m2_22)))
        Vector.tabulate(n,n)((i,j)=>
            if(i<l && j<l) c_11(i)(j)
            else if(i<l && j>=l) c_12(i)(j-l)
            else if(i>=l && j<l) c_21(i-l)(j)
            else c_22(i-l)(j-l))
    }
}
\end{lstlisting}
\textbf{{multStrassen}} \\ \\
\begin{lstlisting}[caption=mult Strassen, label=lst:scala_cod10]
def multStrassen(m1:Matriz, m2:Matriz): Matriz ={
    //recibe m1 y m2 matrices cuadradas de la misma dimension, potencia de 2
    //y devuelve la multiplicacion de las 2 matrices
    val n = m1.length
    if(n == 1) {
        Vector(Vector(m1(0)(0)*m2(0)(0)))
    }
    else {           
        val l = n/2
        val (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) = (
            restaMatriz(subMatriz(m2,0,l,l),subMatriz(m1,l,l,l)),
            sumMatriz(subMatriz(m1,0,0,l), subMatriz(m1,0,l,l)),
            sumMatriz(subMatriz(m1,l,0,l), subMatriz(m1,l,l,l)),
            restaMatriz(subMatriz(m2,l,0,l), subMatriz(m2,0,0,l)),
            sumMatriz(subMatriz(m1,0,0,l), subMatriz(m1,l,l,l)),
            sumMatriz(subMatriz(m2,0,0,l), subMatriz(m2,l,l,l)),
            restaMatriz(subMatriz(m1,0,l,l), subMatriz(m1,l,l,l)),
            sumMatriz(subMatriz(m2,l,0,l), subMatriz(m2,l,l,l)),
            restaMatriz(subMatriz(m1,0,0,l), subMatriz(m1,l,0,l)),
            sumMatriz(subMatriz(m2,0,0,l), subMatriz(m2,0,l,l))
        )
        val (p1, p2, p3, p4, p5, p6, p7) = (
            multStrassen(subMatriz(m1,0,0,l), s1),
            multStrassen(s2, subMatriz(m2,l,l,l)),
            multStrassen(s3, subMatriz(m2,0,0,l)),
            multStrassen(subMatriz(m1,l,l,l), s4),
            multStrassen(s5, s6),
            multStrassen(s7, s8),
            multStrassen(s9, s10)
        )
        val (c_11, c_12, c_21, c_22) = (
            restaMatriz(sumMatriz(p5, p4), sumMatriz(p6, p2)),
            sumMatriz(p1, p2),
            sumMatriz(p3, p4),
            restaMatriz(sumMatriz(p1, p5), restaMatriz(p3, p7))
        )
        Vector.tabulate(n,n)((i,j)=>
            if(i<l && j<l) c_11(i)(j)
            else if(i<l && j>=l) c_12(i)(j-l)
            else if(i>=l && j<l) c_21(i-l)(j)
            else c_22(i-l)(j-l))
    }
}
\end{lstlisting}
\textbf{{multStrassenPar}} \\ \\
\begin{lstlisting}[caption=mult Strassen paralela, label=lst:scala_code11]
    def multStrassenPar(m1:Matriz, m2:Matriz): Matriz ={
        //recibe m1 y m2 matrices cuadradas de la misma dimension, potencia de 2
        //y devuelve la multiplicacion de las 2 matrices
        val n = m1.length
        
        /*if(umbral <= n){
            multMatrizRec(m1,m2)
        }*/
        if(n == 1) {
            Vector(Vector(m1(0)(0)*m2(0)(0)))
        }
        else {           
            val l = n/2
            val (s1, s2, s3, s4, s5, s6, s7, s8, s9, s10) = (
                restaMatriz(subMatriz(m2,0,l,l), 
                            subMatriz(m1,l,l,l)),
                sumMatriz(subMatriz(m1,0,0,l), 
                          subMatriz(m1,0,l,l)),
                sumMatriz(subMatriz(m1,l,0,l), 
                          subMatriz(m1,l,l,l)),
                restaMatriz(subMatriz(m2,l,0,l), 
                            subMatriz(m2,0,0,l)),
                sumMatriz(subMatriz(m1,0,0,l), 
                          subMatriz(m1,l,l,l)),
                sumMatriz(subMatriz(m2,0,0,l), 
                          subMatriz(m2,l,l,l)),
                restaMatriz(subMatriz(m1,0,l,l),
                            subMatriz(m1,l,l,l)),
                sumMatriz(subMatriz(m2,l,0,l),
                          subMatriz(m2,l,l,l)),
                restaMatriz(subMatriz(m1,0,0,l),
                            subMatriz(m1,l,0,l)),
                sumMatriz(subMatriz(m2,0,0,l),
                          subMatriz(m2,0,l,l))
            )
            val (p1, p2, p3, p4, p5, p6, p7) = (
                task(multStrassenPar(subMatriz(m1,0,0,l), s1)),
                task(multStrassenPar(s2, subMatriz(m2,l,l,l))),
                task(multStrassenPar(s3, subMatriz(m2,0,0,l))),
                task(multStrassenPar(subMatriz(m1,l,l,l), s4)),
                task(multStrassenPar(s5, s6)),
                task(multStrassenPar(s7, s8)),
                task(multStrassenPar(s9, s10))
            )
            val (c_11, c_12, c_21, c_22) = (
                restaMatriz(sumMatriz(p5.join(), p4.join()),sumMatriz(p6.join(), p2.join())),
                sumMatriz(p1.join(),p2.join()),
                sumMatriz(p3.join(),p4.join()),
                restaMatriz(sumMatriz(p1.join(), p5.join()),restaMatriz(p3.join(), p7.join()))
            )            
            Vector.tabulate(n,n)((i,j)=>
                if(i<l && j<l) c_11(i)(j)
                else if(i<l && j>=l) c_12(i)(j-l)
                else if(i>=l && j<l) c_21(i-l)(j)
                else c_22(i-l)(j-l))
        }
    }
\end{lstlisting}
\subsubsection{Argumentación de Corrección}
Argumentación detallada de la corrección para cada uno de los algoritmos de multiplicación de matrices y productos punto.
\subsubsection{Explicación Teórica y Método de Inducción}
Explicación teórica de la corrección y método de inducción o inducción estructural utilizado.
\subsubsection{Conclusión de Corrección}
Conclusión sobre la corrección de cada función.

\subsection{Informe de desempeño de las funciones secuenciales y de las funciones paralelas}
\subsubsection{Resultados de Multiplicación de Matrices}
Tabla comparativa y análisis de desempeño.
\subsubsection{Metodología de Generación de Matrices de Prueba}
Descripción de cómo se generaron las matrices de prueba.
\subsubsection{Análisis de Resultados}
Análisis profundo de los resultados obtenidos.

\subsubsection{Resultados de Producto Punto de Vectores}
Tabla comparativa y análisis de desempeño para las implementaciones de producto punto.
\subsubsection{Impacto de las Dimensiones de los Vectores}
Discusión sobre cómo las dimensiones de los vectores afectan al desempeño.
\subsubsection{Análisis de Resultados del Producto Punto}
Análisis detallado de los resultados del producto punto.

\subsection{Análisis comparativo de las diferentes soluciones}
\subsubsection{Análisis Basado en Resultados}
Comparación entre las versiones secuenciales y paralelas de los algoritmos y su desempeño.
\subsubsection{Eficiencia del Algoritmo de Strassen}
Discusión específica sobre la eficiencia del algoritmo de Strassen en comparación con otros.
\subsubsection{Reflexiones sobre el Paralelismo}
Evaluación crítica del paralelismo de tareas y de datos y su efecto en la eficiencia general.

\section{Conclusiones}
\subsection{Síntesis de Hallazgos}
Resumen de los hallazgos más importantes del informe.
\subsection{Implicaciones de los Resultados}
Discusión sobre las implicaciones de los resultados para futuras investigaciones y aplicaciones prácticas.
\subsection{Recomendaciones}
Recomendaciones basadas en el análisis y desempeño de las funciones estudiadas.

\end{document}