\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{xcolor}

% Configuración de estilo para el código Scala
\lstdefinestyle{scalaStyle}{
    language=Scala,                 % Lenguaje del código
    basicstyle=\ttfamily\small,     % Estilo básico de fuente y tamaño
    keywordstyle=\color{blue},      % Estilo para palabras clave
    commentstyle=\color{green},     % Estilo para comentarios
    numbers=left,                   % Mostrar números de línea a la izquierda
    numberstyle=\tiny,              % Estilo de los números de línea
    frame=single,                   % Un marco alrededor del código
    breaklines=true,                % Permitir saltos de línea automáticos
    captionpos=b,                   % Posición de la leyenda
}

\graphicspath{ {./images/} }
\title{
  \begin{figure}[th]
    \centering
    \includegraphics[width=0.2\textwidth]{Univalle}
  \end{figure}
  \textbf{Universidad del Valle
    \\{\Large Facultad de ingeniería}
  \\{\large Ingeniería en sistemas}}}
\author{Cristian David Pacheco Torres
  \\ 2227437
  \\ Juan Sebastian Molina Cuellar
  \\ 2224491}
\date{Septiembre 2023}
\begin{document}
\maketitle
Taller 2
\newpage{}
\begin{abstract}
Your abstract goes here functional programming
\end{abstract}
\newpage{}
\tableofcontents
\newpage{}
\section{Introduction}
A introduction a ver asdf 
\section{Taller 1 : Funciones de alto orden:}
Para el desarrollo de este taller, se utilizaron las siguientes funciones en scala: \\

\section{Funciones de alto orden implementadas}

A continuación, se presenta la funciones implementadas de alto orden, las cuales fueron utilizadas para instanciar otras funciones (funciones generadoras), a través de su paso como parámetro, ya sea referenciada (nominada) o como funcion anónima(inline), o como valor retorno de la misma. \\[16pt]

\begin{table}
 \scriptsize
\begin{tabular}{ |p{4cm}||p{3cm}|p{5.5cm}|  }
 \hline
 \multicolumn{3}{|c|}{Funciones de alto orden} \\
 \hline
 Función& Forma de alto orden  & Expresión donde aparece\\
 \hline
  $Chip$ & Retorno & Retorno de funciones crearChipunario, crearChipBinario, half\_adder, full\_adder, adder\\
  \hline
  $(x:Int) \Rightarrow (x - 1)$  & Lambda como argumento &  $crearChipUnario((x:Int) \Rightarrow (x - 1)):Chip$\\
  \hline
  $ (x: Int, y: Int ) => (x * y)$  & Lambda como argumento &  $crearChipBinario((x: Int, y: Int ) => (x * y)): Chip$\\
  \hline
  $(x: Int, y: Int ) => (x + y) - (x * y )$  & Lambda como argumento &  $crearChipBinario((x: Int, y: Int ) => (x + y) - (x * y )): Chip$\\
\hline
  $half\_adder$ & Variable la cual se asigna una función de retorno & val $half\_adder$ = $( operands: List[Int]) => \{~...~ \}$\\
\hline
  $full\_adder$& Variable la cual se asigna una función de retorno  & val $full\_adder$ = $( operands: List[Int]) => \{~...~ \}$\\
\hline
  $adder$& Variable la cual se asigna una función de retorno & val $adder$ = $( operands: List[Int]) => \{~...~ \}$ \\
 \hline
\end{tabular}
\centering
\caption{Funciones de alto orden realizadas en la implementación del circuito lógico.}
\label{tabla:1}
\end{table}

\section{Crear chip unario}
\subsection{Informe de procesos}
Realiza una operación logica sobre un solo valor de entrada. A continuación, se presenta su implementación en $Scala$ \\[16pt]
\begin{lstlisting}[style=scalaStyle, caption=Aplica una operación binaria sobre una valor de entrada.]
  def crearChipUnario( f: Int => Int ) : Chip = (arg: List[Int]) => { // Apply the f function on the head of current list and call recursively the crearChipUnarioHelper with function f, a accumulated list with new transformed value as its head, and the current list tail, until the empty list condition is reached.
    @tailrec
    def crearChipUnarioHelper(f: Int => Int, transformedList: List[Int],  currentList: List[Int]): List[Int] =
      if (currentList.isEmpty) transformedList
      else crearChipUnarioHelper(f, f(currentList.head)::transformedList, currentList.tail)

    // The initial state of the iteration
    crearChipUnarioHelper(f, List(), arg)
  }
\end{lstlisting}
\subsection{Informe de corrección}
$val~chip\_not = crearchipUnario(x => 1- x)$ \\ \\
Caso 1: \\ 
$chip\_not((List(0)))$ \\
$\rightarrow crearChipUnarioHelper(x => 1 - x, [~], ~List(0))$ \\
$\rightarrow if (List(0).isEmpty)~[~] $ \\
$~~~~~else~crearChipUnarioHelper(x => 1 - x, (1 - 0)::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[1] $ \\
$~~~~~else~crearChipUnarioHelper(x => 1 - x, (1 - 1)::[1], [~])$ \\
$\rightarrow [1]$ \\ \\
Caso 2: \\ 
$chip\_not((List(1)))$ \\
$\rightarrow crearChipUnarioHelper(x => 1- x, [~], List(1))$ \\
$\rightarrow if (List(1).isEmpty)~[~] $ \\
$~~~~~else~crearChipUnarioHelper(x => 1 - x, (1 - 1)::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[0] $ \\
$~~~~~else~crearChipUnarioHelper(x => 1 - x, (1 - 0)::[0], [~])$ \\
$\rightarrow [0]$ \\ \\


\section{Crear chip binario}
\subsection{Informe de procesos}
Realiza una operación logica sobre un solo valor de entrada. A continuación, se presenta su implementación en $Scala$ \\[16pt]
\begin{lstlisting}[style=scalaStyle, caption=Aplica una operación binaria sobre una valor de entrada.]
  def crearChipUnario( f: Int => Int ) : Chip = (arg: List[Int]) => { // Apply the f function on the head of current list and call recursively the crearChipUnarioHelper with function f, a accumulated list with new transformed value as its head, and the current list tail, until the empty list condition is reached.
    @tailrec
    def crearChipUnarioHelper(f: Int => Int, transformedList: List[Int],  currentList: List[Int]): List[Int] =
      if (currentList.isEmpty) transformedList
      else crearChipUnarioHelper(f, f(currentList.head)::transformedList, currentList.tail)

    // The initial state of the iteration
    crearChipUnarioHelper(f, List(), arg)
  }
\end{lstlisting}
\subsection{Informe de corrección}
$val~chip\_and = crearChipBinario((x: Int, y: Int) => x*y~)$ \\ \\
Caso 1: \\ 
$chip\_and((List(0, 0)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => x*y, [~], ~List(0,~0))$ \\
$\rightarrow if ( List(0,~0).isEmpty | List(0, ~0).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => x*y,  (0*0)::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[0] $ \\
$\rightarrow [0]$ \\ \\
Caso 2: \\ 
$chip\_and((List(0, 1)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => x*y, [~], ~List(0,~1))$ \\
$\rightarrow if ( List(0,~1).isEmpty | List(0, ~1).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => x*y,  (0*1)::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[0] $ \\
$\rightarrow [0]$ \\ \\
Caso 2: \\ 
$chip\_not((List(0)))$ \\
$\rightarrow crearChipUnarioHelper(x => 1 - x, [~], ~List(0))$ \\
$\rightarrow if (List(0).isEmpty)~[~] $ \\
$~~~~~else~crearChipUnarioHelper(x => 1 - x, (1 - 0)::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[1] $ \\
$~~~~~else~crearChipUnarioHelper(x => 1 - x, (1 - 1)::[1], [~])$ \\
$\rightarrow [1]$ \\ \\
Caso 3: \\ 
$chip\_and((List(1,~1)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => x*y, [~], ~List(1,~1))$ \\
$\rightarrow if ( List(1,~1).isEmpty | List(1, ~1).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => x*y,  (1*1)::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[1] $ \\
$\rightarrow [1]$ \\ \\

\subsection{Informe de corrección}
$val~chip\_or = crearChipBinario((x: Int, y: Int) => x*y~)$ \\ \\
Caso 1: \\ 
$chip\_or((List(0, 0)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => (x+y) - (x*y), [~], ~List(0,~0))$ \\
$\rightarrow if ( List(0,~0).isEmpty | List(0, ~0).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => (x+y) - (x*y),  ((0+0)-(0*0))::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[0] $ \\
$\rightarrow [0]$ \\ \\
Caso 2: \\ 
$chip\_or((List(0, 1)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => x*y, [~], ~List(0,~1))$ \\
$\rightarrow if ( List(0,~1).isEmpty | List(0, ~1).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => (x+y)-(x*y),  ((0+1)-(0*1))::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[1] $ \\
$\rightarrow [1]$ \\ \\
Caso 3: \\ 
$chip\_or((List(1, 0)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => x*y, [~], ~List(1,~0))$ \\
$\rightarrow if ( List(0,~1).isEmpty | List(1, ~0).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => (x+y)-(x*y),  ((1+0)-(1*0))::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[1] $ \\
$\rightarrow [1]$ \\ \\
Caso 4: \\ 
$chip\_or((List(1,~1)))$ \\
$\rightarrow crearChipBinarioHelper((x: Int, y: Int) => x*y, [~], ~List(1,~1))$ \\
$\rightarrow if ( List(1,~1).isEmpty | List(1, ~1).tail.isEmpty)~[~] $ \\
$~~~~~else~crearChipBinarioHelper((x: Int, y: Int) => x*y,  ((1+1)-(1*1))::[~], [~])$ \\
$\rightarrow if (List().isEmpty)~[1] $ \\
$\rightarrow [1]$ \\ \\

\subsection{Informe de corrección}

$half\_adder(List(0,~0))$\\
$\rightarrow val~and\_op\_in = chip\_add(List(0,~0))$\\
$~~~~~val~or\_op = chip\_or(List(0,~0))$\\
$~~~~~val~and\_op\_out = chip\_add(List(0)~~++~~chip\_not(List(0)))$\\
$~~~~~List(0)~~++~~List(0)$\\
$\rightarrow [0,~0]$\\ \\
$half\_adder(List(0,~1))$\\
$\rightarrow val~and\_op\_in = chip\_add(List(0,~1))$\\
$~~~~~val~or\_op = chip\_or(List(0,~1))$\\
$~~~~~val~and\_op\_out = chip\_add(List(1)~~++~~chip\_not(List(0)))$\\
$~~~~~List(1)~~++~~List(0)$\\
$\rightarrow [1,~0]$\\ \\
$half\_adder(List(1,~0))$\\
$\rightarrow val~and\_op\_in = chip\_add(List(1,~0))$\\
$~~~~~val~or\_op = chip\_or(List(1,~0))$\\
$~~~~~val~and\_op\_out = chip\_add(List(1)~~++~~chip\_not(List(0)))$\\
$~~~~~List(1)~~++~~List(0)$\\
$\rightarrow [1,~0]$\\ \\
$half\_adder(List(1,~1))$\\
$\rightarrow val~and\_op\_in = chip\_add(List(1,~1))$\\
$~~~~~val~or\_op = chip\_or(List(1,~1))$\\
$~~~~~val~and\_op\_out = chip\_add(List(1)~~++~~chip\_not(List(1)))$\\
$~~~~~List(0)~~++~~List(1)$\\
$\rightarrow [0,~1]$\\ \\

\subsection{Informe de corrección}

Caso 0 + 0, Carriage:=0:\\
$full\_adder(List(0,~0,~0))$\\
$\rightarrow~val~halfAdder\_1 = half\_adder(0::0::Nil)$ \\
$~~~~~val~halfAdder\_2 = half\_adder(0::0::Nil)$ \\
$~~~~~val~or\_op = chip\_or(List(0)~~++~~List(0))$ \\
$~~~~~List(0)~~++~~List(0)$ \\
$\rightarrow [0,~0]$\\ \\
Caso 0 + 0, Carriage:=0:\\
$full\_adder(List(0,~0,~1))$\\
$\rightarrow~val~halfAdder\_1 = half\_adder(0::1::Nil)$ \\
$~~~~~val~halfAdder\_2 = half\_adder(0::1::Nil)$ \\
$~~~~~val~or\_op = chip\_or(List(0)~~++~~List(0))$ \\
$~~~~~List(0)~~++~~List(1)$ \\ 
$\rightarrow [0,~1]$\\ \\
Caso 1 + 0:\\
$full\_adder(List(0,~1,~1))$\\
$\rightarrow~val~halfAdder\_1 = half\_adder(1::1::Nil)$ \\
$~~~~~val~halfAdder\_2 = half\_adder(0::1::Nil)$ \\
$~~~~~val~or\_op = chip\_or(List(0)~~++~~List(0))$ \\
$~~~~~List(0)~~++~~List(1)$ \\ 
$\rightarrow [0,~1]$\\ \\
Caso 0 + 1, Carriage:=0:\\
$full\_adder(List(0,~1,~0))$\\
$\rightarrow~val~halfAdder\_1 = half\_adder(1::0::Nil)$ \\
$~~~~~val~halfAdder\_2 = half\_adder(0::1::Nil)$ \\
$~~~~~val~or\_op = chip\_or(List(0)~~++~~List(0))$ \\
$~~~~~List(0)~~++~~List(1)$ \\
$\rightarrow [0,~1]$\\ \\

Caso 1 + 1, Carriage:=0:\\
$full\_adder(List(1,~1,~0))$\\
$\rightarrow~val~halfAdder\_1 = half\_adder(1::0::Nil)$ \\
$~~~~~val~halfAdder\_2 = half\_adder(1::1::Nil)$ \\
$~~~~~val~or\_op = chip\_or(List(0)~~++~~List(1))$ \\
$~~~~~List(1)~~++~~List(0)$ \\
$\rightarrow [1,~0]$\\ \\

Caso 1 + 1, Carriage:=1:\\
$full\_adder(List(1,~1,~1))$\\
$\rightarrow~val~halfAdder\_1 = half\_adder(1::1::Nil)$ \\
$~~~~~val~halfAdder\_2 = half\_adder(1::0::Nil)$ \\
$~~~~~val~or\_op = chip\_or(List(1)~~++~~List(0))$ \\
$~~~~~List(1)~~++~~List(0)$ \\
$\rightarrow [1,~0]$\\ \\

\subsection{Informe de corrección}

$val ~add\_4 = adder(4)$ \\
$add\_4(List(0,0,1,1)~~++~~List(1, 1, 1, 1))$ \\
$\rightarrow splitList(4, 0, List(), List(0,0,1,1,1,1,1,1))$ \\
$\rightarrow~if(4 == 0) ~(List(), List(0,0,1,1,1,1,1,1))$\\
$~~~~~else~spplitList(4, 1, 0::List(), List(0,1,1,1,1,1,1))$ \\
$\twoheadrightarrow~if(4 == 4) ~(List(0,0,1,1), ~List(1,1,1,1))$\\
$\rightarrow~val~(l1,~l2)=(List(0,0,1,1), ~List(1,1,1,1))$ \\
$\rightarrow~adderHelper( half\_adder(0::1::Nil), List(0,1,1), List(1,1,1) )$ \\
$\rightarrow~adderHelper( List(1,0), List(0,1,1), List(1,1,1) )$ \\
$\rightarrow~if( List(0,1,1).isEmpty || List(1,1,1).isEmpty ) List(1,~0)$ \\
$~~~~~val~fullAddResult = full\_adder(0::1::1::Nil)$ \\
$~~~~~adderHelper( List(1, 0) ++ List(0), List(1,1), List(1,1))$ \\
$\twoheadrightarrow~if(List().isEmpty~||~List().isEmpty) ~List(1,0,0,1,0)$\\
$\rightarrow~[1,0,0,1,0]$
\section{Conclusion}
La conclusion
\newpage{}
\begin{displaymath}
 a = \sum F \dot m = \frac{dv}{dt}
\end{displaymath}

\end{document}
List[Int] \Rightarrow List[Int]